<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Security" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Runtime.Remoting.Messaging" #>
<#@ output extension=".Designer.cs" #><#

string candidate = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), Path.GetFileNameWithoutExtension(Host.TemplateFile) + ".resx");
string className = GetFriendlyName(Path.GetFileNameWithoutExtension(candidate));

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------

namespace <#= GetNamespace() #> {
    using System;

	///<summary>
	/// Provides access to resource key names for the <#= className #> resource file.
	///</summary>
	[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
	[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
	internal class <#= className #> {
		private static global::System.Resources.ResourceManager resourceManager;
		private static global::System.Globalization.CultureInfo resourceCulture;

		[global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
		internal <#= className #>() {
		}

		/// <summary>
		/// Returns the cached ResourceManager instance used by this class.
		/// </summary>
		[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
		internal static global::System.Resources.ResourceManager ResourceManager {
			get {
				if (object.ReferenceEquals(resourceManager, null)) {
					global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("<#= GetNamespace() #>.<#= className #>", typeof(<#= className #>).Assembly);
					resourceManager = temp;
				}
				return resourceManager;
			}
		}
        
		/// <summary>
		/// Overrides the current thread's CurrentUICulture property for all
		/// resource lookups using this strongly typed resource class.
		/// </summary>
		[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
		internal static global::System.Globalization.CultureInfo Culture {
			get {
				return resourceCulture;
			}
			set {
				resourceCulture = value;
			}
		}

<# foreach(var resource in ReadResources(Host.ResolvePath(candidate))) { 
        int numberOfArguments = FormatParse(resource.Item2);
        if (numberOfArguments > 0) {
            var list = Enumerable.Range(0, numberOfArguments).ToList();
            var arguments0 = string.Join(", ", list.ConvertAll(x => "object arg" + x.ToString()));
            var arguments1 = string.Join(", ", list.ConvertAll(x => "arg" + x.ToString()));
#>
		/// <summary>
        /// Formats a localized string similar to '<#= SecurityElement.Escape(resource.Item2) #>'.
		/// </summary>
        /// <returns>A copy of format string in which the format items have been replaced by the String equivalent of the corresponding instances of Object in arguments.</returns>
		internal static string <#= resource.Item1 #>Format(<#= arguments0 #>) {
            return string.Format(resourceCulture, ResourceManager.GetString("<#= resource.Item1 #>", resourceCulture), <#= arguments1 #>);
		}

<#
        }
        else {
#>
		/// <summary>
		/// Looks up a localized string similar to '<#= SecurityElement.Escape(resource.Item2) #>'.
		/// </summary>
		internal static string <#= resource.Item1 #> {
			get {
				return ResourceManager.GetString("<#= resource.Item1 #>", resourceCulture);
			}
		}

<#      } 
}#>
	}
} 

<#+

public static readonly string NamespaceOverride = null; // leave NULL if you want the namespace to match the file location.

public static string GetNamespace()
{
	return !string.IsNullOrEmpty(NamespaceOverride) 
		? NamespaceOverride 
		: CallContext.LogicalGetData("NamespaceHint") as string;
}

public static IEnumerable<Tuple<string, string>> ReadResources(string resourcePath)
{
	return XElement.Load(resourcePath).Descendants("data").Select(x => new Tuple<string, string>(x.Attribute("name").Value, (string)x.Element("value")));
}

private static string GetFriendlyName(string path)
{
	var noExtension = new Regex(@"\.[^\.]+$");
	var strippedPath = noExtension.Replace(path, string.Empty);
	var unfriendlyPattern = new Regex("(?i)[^a-z0-9]+");
	return unfriendlyPattern.Replace(strippedPath, "_");
}

private const string FormatInvalidString = "Input string was not in a correct format.";
private const string FormatIndexOutOfRange = "Index (zero based) must be greater than or equal to zero and less than the size of the argument list.";

private static int FormatParse(string format) {
    if (null == format) {
        throw new ArgumentNullException("format");
    }

    char[] formatChars = format.ToCharArray(0, format.Length);
    int cursor = 0;
    char currChar = '\0';
    List<int> argumentIndexes = new List<int>();

    while (true) {
        int supplementaryCursor = cursor;
        while (cursor < formatChars.Length) {
            currChar = formatChars[cursor];
            cursor++;
            if (currChar == '}') {
                if ((cursor < formatChars.Length) && (formatChars[cursor] == '}')) {
                    cursor++;
                }
                else {
                    FormatError();
                }
            }

            if (currChar == '{') {
                if ((cursor < formatChars.Length) && (formatChars[cursor] == '{')) {
                    cursor++;
                }
                else {
                    cursor--;
                    break;
                }
            }

            formatChars[supplementaryCursor++] = currChar;
        }

        if (cursor == formatChars.Length) {
            // Checking the argument list
            argumentIndexes.Sort();

            for (int argumentIndex = 0; argumentIndex < argumentIndexes.Count; ++argumentIndex) {
                if (argumentIndex != argumentIndexes[argumentIndex]) {
                    throw new FormatException(FormatIndexOutOfRange);
                }
            }

            return argumentIndexes.Count;
        }

        // Checking the first index letter
        cursor++;
        if (((cursor == formatChars.Length) || ((currChar = formatChars[cursor]) < '0')) || (currChar > '9')) {
            FormatError();
        }

        // Getting the index
        int index = 0;
        do {
            index = ((index * 10) + currChar) - 0x30;
            cursor++;
            if (cursor == formatChars.Length) {
                FormatError();
            }

            currChar = formatChars[cursor];
        }
        while (((currChar >= '0') && (currChar <= '9')) && (index < 0xf4240));

        // Storing the index
        if (!argumentIndexes.Contains(index)) {
            argumentIndexes.Add(index);
        }

        while ((cursor < formatChars.Length) && ((currChar = formatChars[cursor]) == ' ')) {
            cursor++;
        }

        // Getting the alignment
        int alignment = 0;
        if (currChar == ',') {
            cursor++;
            while ((cursor < formatChars.Length) && (formatChars[cursor] == ' ')) {
                cursor++;
            }

            if (cursor == formatChars.Length) {
                FormatError();
            }

            currChar = formatChars[cursor];
            if (currChar == '-') {
                cursor++;
                if (cursor == formatChars.Length) {
                    FormatError();
                }

                currChar = formatChars[cursor];
            }

            if ((currChar < '0') || (currChar > '9')) {
                FormatError();
            }

            do {
                alignment = ((alignment * 10) + currChar) - 0x30;
                cursor++;
                if (cursor == formatChars.Length) {
                    FormatError();
                }

                currChar = formatChars[cursor];
            }
            while (((currChar >= '0') && (currChar <= '9')) && (alignment < 0xf4240));
        }

        while ((cursor < formatChars.Length) && ((currChar = formatChars[cursor]) == ' ')) {
            cursor++;
        }

        // object obj1 = args[index];
        string formatString = null;
        if (currChar == ':') {
            cursor++;
            int formatStringBeginning = cursor;
            supplementaryCursor = cursor;
            while (true) {
                if (cursor == formatChars.Length) {
                    FormatError();
                }

                currChar = formatChars[cursor];
                cursor++;
                if (currChar == '{') {
                    if ((cursor < formatChars.Length) && (formatChars[cursor] == '{')) {
                        cursor++;
                    }
                    else {
                        FormatError();
                    }
                }
                else if (currChar == '}') {
                    if ((cursor < formatChars.Length) && (formatChars[cursor] == '}')) {
                        cursor++;
                    }
                    else {
                        cursor--;
                        break;
                    }
                }

                formatChars[supplementaryCursor++] = currChar;
            }

            if (supplementaryCursor > formatStringBeginning) {
                formatString = new string(formatChars, formatStringBeginning, supplementaryCursor - formatStringBeginning);
            }
        }

        if (currChar != '}') {
            FormatError();
        }

        cursor++;
    }
}

private static void FormatError() {
    throw new FormatException(FormatInvalidString);
}

#>